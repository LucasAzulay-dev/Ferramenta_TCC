from .config import *
from src.Ferramenta_TCC import executar_ferramenta
import os.path

class TestFI_1:
    """
    FI#1: The tool must accept as input an SUT file, a project file, the name of the function to be instrumented, and a set of tests.
    """
    def test_1(self, dont_open_report):
        """
        T#1.1: Verify that the tool accepts the required inputs (using xls and gcc).
        """
        case_path = 'tests\\test_cases\\functional_cases\\case_embraer_base'
        executar_ferramenta(
            excel_file_path=case_path + '\\testInputs\\TestVec.xls',
            code_path=case_path+"\\src\\sut.c",
            function_name='sut',
            compiler='gcc',
            bufferLength=33554432
    )

    def test_2(self, dont_open_report):
        """
        t#1.2: Verify that the tool accepts the required inputs (using xlsx and clang).
        """
        case_path = 'tests\\test_cases\\functional_cases\\case_embraer_base'
        executar_ferramenta(
            excel_file_path=case_path + '\\testInputs\\TestVec.xlsx',
            code_path=case_path+"\\src\\sut.c",
            function_name='sut',
            compiler='clang',
            bufferLength=33554432
    )
        
class TestFI_2:
    """
    FI#2: The tool must generate a Test Driver based on the tool's inputs.
    """
    def test_1(self, case_path, execute_functional_case):
        """
        TI#2.1: Verify that the Test Driver is generated by the tool (C and exe files).
        """
        assert os.path.exists(os.path.join(case_path,PATH_TEST_DRIVER_C)) and os.path.exists(os.path.join(case_path,PATH_TEST_DRIVER_EXE))

class TestFI_3:
    """
    FI#3: The tool must generate instrumented code from the SUT.
    """
    def test_1(self, case_path, execute_functional_case):
        """
        TI#3.1: Verify that the instrumented code is generated by the tool.
        """  
        assert os.path.exists(os.path.join(case_path,PATH_INSTRUMENTED_SUT_C))

class TestFI_4:
    """
    FI#4: The Test Driver must execute the tests using the instrumented code.
    """
    def test_1(self, case_path, execute_functional_case):
        """
        TI#4.1: Verify that the Test Driver uses the instrumented code.
        """
        with open(os.path.join(case_path,PATH_TEST_DRIVER_C)) as test_driver:
            assert '#include "instrumented_SUT.h"' in test_driver.read()

class TestFI_6:
    """
    FI#6: The Test Driver must generate an execution log of the tests performed on the instrumented code.
    """
    def test_1(self, case_path, execute_functional_case):
        """
        TI#6.1: Verify that an execution log is generated by the tool.
        """
        assert os.path.exists(os.path.join(case_path, PATH_LOG_BUFFER))

class TestFI_7:
    """
    FI#7: The execution log must indicate whether each performed test passed or failed.
    """
    def test_1(self, get_log_json, execute_functional_case):
        """
        TI#7.1: Verify that the execution log has an indication of each test outcome.
        """
        json_out = get_log_json()
        assert all(execution.get("pass") in ["true", "false"] for execution in json_out.get("executions", []))

    def test_2(self, get_log_json, oracle_tests_passed, execute_functional_case):
        """
        TI#7.2: Verify that the outcome of each test indicated in the execution log is according to the expected outcome in the oracleâ€™s test case.
        """
        json_out = get_log_json()
        actual_tests_passed = [execution.get("pass") for execution in json_out.get("executions", [])]
        assert actual_tests_passed == oracle_tests_passed

class TestFI_8:
    """
    FI#8: The execution log must specify which components were executed in an ordered manner.
    """
    def test_1(self, get_log_json, oracle_functions_called_ordered, execute_functional_case):
        """
        TI#8.1: Verify that the execution log indicates the execution order of the components for each test.
        """
        json_out = get_log_json()
        total_executions = len(json_out.get("executions",[]))
        actual_functions_called_ordered = [
            analysis.get("function")
            for execution in json_out.get("executions", [])
            for analysis in execution.get("analysis",[])
        ]
        # Assuming that the execution order is the same for all executions
        assert actual_functions_called_ordered == oracle_functions_called_ordered * total_executions

class TestFR_1:
    """
    FI#8: The execution log must specify which components were executed in an ordered manner.
    """
    def test_1(self, case_path, execute_functional_case):
        """
        TR#1.1: Verify that a report is generated by the tool (2 pdf files containing a diagram and a DC/CC report).
        """    
        assert os.path.exists(os.path.join(case_path,PATH_REPORT_PDF)) and os.path.exists(os.path.join(case_path,PATH_DIAGRAM_PDF))

